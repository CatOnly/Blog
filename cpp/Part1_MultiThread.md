[TOC]

<h1><center>多线程并发编程</center></h1>



# 一、基础概念

> 一般在某些操作会阻塞主线程时，使用多线程，将这些操作放到其他线程中做到并发



## 1. 进程 process

> 进程就像工厂的车间



进程是 CPU 所能处理的单个任务 Task，同一时刻，CPU 总是执行一个进程

- 系统中正在运行的**一个程序**
- 每个进程之间相互独立（运行在其专用且受保护的内存空间内）
- 进程之间可以相互通讯



## 2. 线程 thread

> 线程就像车间里的工人
> 一个车间里，可以有很多个工人，他们共享车间的资源，协同合作



一个线程由线程 ID、当前指令指针（PC）、寄存器集合和堆栈组成

- 1 个进程想执行任务，必须得有 1 条线程（每个进程至少有一条线程）
- 1 个进程所有的任务都在线程里执行
- 1 个线程的任务的**执行都是串行**（按顺序多个任务，同一时间内 1 个线程只执行 1 个任务）



### 2.1 线程的访问权限

线程，有时候也被称为轻量级进程（Lightweight Process，LWP）

![](./images/thread.png)



### 2.2 线程调度与优先级

**线程的状态切换**：
其中拥有**因时间片用尽，而切换为就绪状态**的功能的线程叫可抢占线程（现在大部分操作系统的线程都是可抢占线程）

- Ready 就绪：此时线程可以立刻执行，但 CPU 已经被其他线程占用
- Wait 等待：此时线程正在等待某一时间发生（通常是 I/O 或同步），无法执行
- Running 运行：此时线程正在执行

![](./images/thread2.png)



**线程的优先级调度**

各个线程，按照线程的优先级顺序轮流执行一小段时间

改变线程优先级的方法有：

1. 用户指定优先级
线程的优先级可以手动设置，系统会根据线程的实际表现自动调整
2. 根据进入等待的频繁程度提升或降低优先级
  IO 密集（频繁等待）线程的优先级 >  CPU 密集（很少等待）线程的优先级
3. 长时间得不到执行的线程提升优先级
  防止 Starvation 饿死现象：一个饿死的线程总是有比它优先级高的线程执行，导致这个线程始终无法执行



### 2.3 Linux 系统调用的多线程

>  UNIX 程序的调用过程
> **程序** $\to$ **C/C++ 标准库**(编译器提供) $\to$ **POSIX 标准库**(操作系统提供的系统调用) $\to$ **操作系统服务**

在 Linux 平台的 POSIX 库规定的多线程中进程和线程的界限比较模糊

Linux 中只有任务 Task，没有线程和进程的实体

- 一个任务可以看做只含有一个线程的进程
- 多个任务可以共享内存空间构成一个进程，而这些任务便成了这个进程的线程



**Linux 多线程的系统调用函数**

1. clone：产生一个新的 task，并可以设置产生的 task 和原 task 共享的数据
   相当于在进程中产生一个线程

2. fork：快速产生一个新的 task，并不复制原 task 的内存空间和原 task 共享一个**写时复制**的内存空间
   相当于深拷贝出一个进程

   > 写时复制（Copy on Write，COW）：
   >
   > - 只要一直不写入内存：都读同一份内存
   > - 一旦需要写入内存时：复制原 task 内存供当前 task 读写，当前 task 以后就不在原 task 读内存（以免影响其他 task 使用）

3. exec：将新 fork 出来的 task 设置为当前执行的 task

   



# 二、线程安全

原子操作：不会被系统的线程调度打断的操作，例 C 或 C++ 代码的原子操作编译成汇编的机器代码后**是一条汇编指令**



## 1. 二元信号量 Binary Semaphore

> 有些车间只能容纳一个工人工作
> 车间外的其他工人根据是否上锁来判断是否需要在车间外排队等候

同一个信号量：可以被系统中的一个**线程/进程**获取，被另一个**线程/进程**释放

二元信号量，只有两种状态：占用、非占用



## 2. 信号量 Semaphore

> 有些车间只能容纳多个工人工作
> 信号量表示当前车间的工作人数

同一个信号量：可以被系统中的一个**线程/进程**获取，被另一个**线程/进程**释放

信号量，全程多元信号量
允许多个线程并发访问资源，一个初始值为 N 的信号量允许 N 个线程并发访问



## 3. 互斥锁 Mutex

互斥锁 Mutual exclusion，缩写 Mutex，防止多个线程同时读写某一块内存区域，比二元信号量更为严格

同一个互斥锁：谁获取，谁释放



## 4. 临界区 Critical Section

比互斥锁更为严格：作用范围仅限于本进程，其他进程无法获取

- 获取锁：进入临界区

- 释放锁：离开临界区



## 5. 读写锁 Read-Write Lock

读写锁：避免了读取频繁，偶尔写入时，其它锁的低效率

| 读写锁状态 | 以共享的方式获取读写锁 | 以独占的方式获取读写锁 |
| :--------- | ---------------------- | ---------------------- |
| 自由       | 成功                   | 成功                   |
| 共享       | 成功                   | 等待 其它线程释放锁    |
| 独占       | 等待 其它线程释放锁    | 等待其它线程释放锁     |



## 6. 可重入 Re-entrant

一个函数被重入：这个函数没有执行完成，又一次进入该函数执行（由于外部因素或内部调用）

一个函数被称为可重入的，表示该函数被重入后不会产生任何不良的后果
可重入函数有以下特点

1. 没有任何 局部的静态 或 全局的非 const 变量
2. 仅依赖调用方的参数
3. 不依赖任何单个资源的锁（mutex 等）



## 7. 防止编译器过度优化

CPU 的动态调度：在执行程序的时候，为了提高效率有可能**交换指令的执行顺序**
编译器在进行优化的时候，可能为了效率而交换毫不相干的两条相邻指令的执行顺序

关键字 **volatile**，防止编译器过度优化（无法阻止 CPU 动态调度换序）

- 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回
- 阻止编译器调整操作 volatile 变量的指令顺序



应用：单例设计模式的线程安全

```c
volatile T* pInst = 0;
T* GetInstance()
{
  if (!pInst)		// double-check 双重校验，这个 if 减少 lock 的调用
  {
    lock();
    if (!pInst)
    {
      // 错误的方式
      // pInst = new T; // 此行代码包涵三步骤：
      									// 1.分配内存空间 2.执行构造函数 3.将分配的空间指针赋值给 pInst
      									// 其中，2，3 步骤可以被编译器优化而颠倒顺序
      									// 出现 pInst 有值但没有被初始化的情况，导致线程锁失效
      
      // 正确的方式
      T* temp = new T;
      __asm__ volatile ("lwsync") // 插入汇编指令，阻止 CPU 动态交换该指令前后的位置
      pInst = temp;
    }
    unlock();
  }
  
  return pInst;
}
```





# 三、线程模型

## 1. 一对一模型

一个用户态的线程对应一个内核态的线程，反过来不一定（有些内核态线程在用户态可能没有与之对应的线程）

来源：直接使用 POSIX 协议的 API 或 系统调用的方法创建的线程（在内核态有对应的一个线程）

优点：

- 线程之间是真正的并发
- 多线程程序在多任务处理器上有更好的表现

缺点：

- 操作系统会限制内核线程的数量，导致了用户线程的数量被限制
- 操作系统内核线程切换上下文开销大，导致了用户线程执行效率低



## 2. 多对一模型

多个用户态的线程对应一个内核态的线程

优点：

- 用户线程切换较快
- 用户线程数量几乎不限制

缺点：

- 一个用户线程阻塞，对应其他用户态的线程（对应同一个内核态线程）也会阻塞
- 多任务处理器的提升，对多对一模型线程不会有明显的帮助



## 3. 多对多模型

多个用户态的线程对应少数但不止一个内核态的线程

- 用户线程切换较快
- 用户线程数量几乎不限制
- 多任务处理器的提升，对多对多模型会有提升，不过提升幅度不如一对一模型大





# 参考

- [Processes and Threads](http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html)

- [Using the Clone() System Call](https://www.linuxjournal.com/article/5211)

- [二值信号量和互斥锁到底有什么区别？](https://www.cnblogs.com/codescrew/p/8970514.html)