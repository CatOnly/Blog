[TOC]

# ä¸€ã€åŸºç¡€

## 1. æ—¶é—´å¤æ‚åº¦åˆ†æ

ç¨‹åºå¤æ‚åº¦æµ‹è¯•çš„å¤–éƒ¨å› ç´ 

1. æµ‹è¯•ç»“æœéå¸¸ä¾èµ–æµ‹è¯•ç¯å¢ƒ
2. æµ‹è¯•ç»“æœå—æ•°æ®è§„æ¨¡çš„å½±å“å¾ˆå¤§



æ—¶é—´å¤æ‚åº¦çš„åˆ†æ

1. å¤æ‚åº¦çš„åˆ†æä¸ä¸€å®šè¦ç²¾ç¡®ï¼Œæœ‰æ—¶å€™ä¸ºäº†å¿«é€Ÿåˆ†æå¯ä»¥å¾ˆç²—ç•¥
   ä¸€èˆ¬ï¼Œåªå…³æ³¨å¾ªç¯æ‰§è¡Œæ¬¡æ•°æœ€å¤šçš„ä¸€æ®µä»£ç 
2. æ—¶é—´å¤æ‚åº¦ååº”çš„æ˜¯æ•°æ®è§„æ¨¡ n å¾ˆå¤§çš„æ—¶å€™çš„ä¸€ä¸ªå¢é•¿è¶‹åŠ¿
   ä¸€èˆ¬**ç³»æ•°ã€å¸¸æ•°ã€ä½é˜¶**ä¼šè¢«å¿½ç•¥ï¼Œä½†åœ¨å®é™…å¼€å‘ä¸­ç”±äºä½¿ç”¨çš„æ•°æ®è§„æ¨¡ä¸€èˆ¬éƒ½ä¸å¤§
   åè€Œéœ€è¦è€ƒè™‘**ç³»æ•°ã€å¸¸æ•°ã€ä½é˜¶**
3. åŠ æ³•æ³•åˆ™ï¼šæ€»å¤æ‚åº¦ç­‰äºé‡çº§æœ€å¤§çš„é‚£æ®µä»£ç çš„å¤æ‚åº¦
4. ä¹˜æ³•æ³•åˆ™ï¼šåµŒå¥—ä»£ç çš„å¤æ‚åº¦ç­‰äºåµŒå¥—å†…å¤–ä»£ç å¤æ‚åº¦çš„ä¹˜ç§¯



å¤šä¸ªè®¡ç®—çš„æ€»æ—¶é—´å¤æ‚åº¦åˆ†æ

1. å¹³å‡å¤æ‚åº¦åˆ†æï¼šå¹³å‡è®¡ç®—æ¯ä¸ªå¤æ‚åº¦å€¼
2. å‡æ‘Šå¤æ‚åº¦åˆ†æï¼šæ ¹æ®æ¯ä¸ªå¤æ‚çš„è®¡ç®—å‡ºç°æ¦‚ç‡ * å¤æ‚åº¦ï¼Œç´¯åŠ åå¾—åˆ°çš„æœ€ç»ˆå¤æ‚åº¦



å¸¸ç”¨æ—¶é—´å¤æ‚åº¦å¤§å°çš„æ¯”è¾ƒ

- ç”±äºå¯¹æ•°å¯ä»¥äº’ç›¸è½¬æ¢ $log_{10}n = log_{10}2 \cdot log_2n = C_{å¸¸æ•°}log_2n$

  ä¸ç®¡æ˜¯ä»¥ 2 ä¸ºåº•ã€ä»¥ 3 ä¸ºåº•ï¼Œè¿˜æ˜¯ä»¥ 10 ä¸ºåº•å¤æ‚åº¦éƒ½è®¡åš logn
  
- æ—¶é—´å¤æ‚åº¦ lognï¼Œä¸ç®¡é—®é¢˜ n æœ‰å¤šå¤§ï¼Œæœ€å logn æ€»ä¼šç»´æŒåœ¨ä¸€ä¸ªè¾ƒå°çš„èŒƒå›´ä¸‹ï¼Œå¦‚ä¸‹å›¾

<img src="./images/asymptotic_time_complexity.png" style="zoom:67%;" />



## 2. ä½¿ç”¨å“¨å…µ

ä¾‹ï¼š
åœ¨æ•°ç»„ a ä¸­ï¼ŒæŸ¥æ‰¾ keyï¼Œè¿”å› key æ‰€åœ¨çš„ä½ç½®
å…¶ä¸­ï¼Œn è¡¨ç¤ºæ•°ç»„ a çš„é•¿åº¦

- ä¸€èˆ¬åšæ³•

  ```c
  int find(char* a, int n, char key) {  
    // è¾¹ç•Œæ¡ä»¶å¤„ç†ï¼Œå¦‚æœ a ä¸ºç©ºï¼Œæˆ–è€… n<=0ï¼Œè¯´æ˜æ•°ç»„ä¸­æ²¡æœ‰æ•°æ®ï¼Œå°±ä¸ç”¨ while å¾ªç¯æ¯”è¾ƒäº†  
    if(a == null || n <= 0) {    
      return -1;  
    }
    
    int i = 0;  
    // è¿™é‡Œæœ‰ä¸¤ä¸ªæ¯”è¾ƒæ“ä½œï¼ši<n å’Œ a[i]==key
    while (i < n) {    
      if (a[i] == key) {      
        return i;
      }
      ++i;
    }
    return -1;
  }
  ```



- ä½¿ç”¨å“¨å…µ
  å¯ä»¥çœå»å¾ªç¯ä½“ä¸­çš„åˆ¤æ–­æ“ä½œï¼Œä»è€Œè¾¾åˆ°ç®€åŒ–é—®é¢˜çš„ç›®çš„

  ```c
  // é€šè¿‡å‡å°å¾ªç¯ä½“ä¸­çš„æ¯”è¾ƒæ¬¡æ•°(è€—æ—¶æœ€å¤šçš„åœ°æ–¹)ï¼Œæ¥æå‡æ•ˆç‡
  // ä¾‹ï¼šchar *a = {'4','2','3','5','9','6'} n=6 key='7'
  int find(char* a, int n, char key) {  
    if(a == null || n <= 0) {    
      return -1;
    }
    
    // è¿™é‡Œå› ä¸ºè¦å°† a[n-1] çš„å€¼æ›¿æ¢æˆ keyï¼Œæ‰€ä»¥è¦ç‰¹æ®Šå¤„ç†è¿™ä¸ªå€¼  
    if (a[n-1] == key) {
      return n-1;
    }
    
    // æŠŠ a[n-1] çš„å€¼ä¸´æ—¶ä¿å­˜åœ¨å˜é‡ tmp ä¸­ï¼Œä»¥ä¾¿ä¹‹åæ¢å¤ tmp='6'   
    // ä¹‹æ‰€ä»¥è¿™æ ·åšçš„ç›®çš„æ˜¯ï¼šå¸Œæœ›find()ä»£ç ä¸è¦æ”¹å˜aæ•°ç»„ä¸­çš„å†…å®¹
    char tmp = a[n-1];
    
    // æŠŠ key çš„å€¼æ”¾åˆ° a[n-1] ä¸­ï¼Œæ­¤æ—¶ a = {'4','2','3','5','9','7'}
    a[n-1] = key;
    
    int i = 0;
    // while å¾ªç¯æ¯”èµ·ä»£ç ä¸€ï¼Œå°‘äº† i<n è¿™ä¸ªæ¯”è¾ƒæ“ä½œ
    while (a[i] != key) {
      ++i;
    }
    
    // æ¢å¤ a[n-1] åŸæ¥çš„å€¼,æ­¤æ—¶ a= {'4','2','3','5','9','6'}
    a[n-1] = tmp;
    
    if (i == n-1) {
      // å¦‚æœ i == n-1 è¯´æ˜ï¼Œåœ¨ 0...n-2 ä¹‹é—´éƒ½æ²¡æœ‰ keyï¼Œæ‰€ä»¥è¿”å› -1
      return -1;
    } else {
      // å¦åˆ™ï¼Œè¿”å› iï¼Œå°±æ˜¯ç­‰äº key å€¼çš„å…ƒç´ çš„ä¸‹æ ‡
      return i;  
    }
  }
  ```



## 3. é€’å½’

ç»“æ„

1. **é€’æ¨å…¬å¼**ï¼Œä¾‹ï¼š$F(n) = F(n-1) * F(n-2)$
   ä¸€ä¸ªé—®é¢˜çš„è§£å¯ä»¥åˆ†è§£ä¸ºå‡ ä¸ªå­é—®é¢˜çš„è§£
   è¿™ä¸ªé—®é¢˜ä¸åˆ†è§£ä¹‹åçš„å­é—®é¢˜ï¼Œé™¤äº†æ•°æ®è§„æ¨¡ä¸åŒï¼Œæ±‚è§£æ€è·¯å®Œå…¨ä¸€æ ·
2. **é€’å½’ç»ˆæ­¢æ¡ä»¶**ï¼Œä¾‹ï¼š$F(1) = 1,\space F(2) = 2$



ç¼ºç‚¹

1. **ç©ºé—´å¤æ‚åº¦é«˜**

   é€’å½’å‡½æ•°å†…çš„å±€éƒ¨å˜é‡è¿‡å¤šï¼Œåœ¨æ ˆå†…é€’å½’è°ƒç”¨çš„æˆæœ¬ä¼šè¿‡é«˜

2. **å †æ ˆæº¢å‡º**
   é€šè¿‡å †æ ˆå‰©ä½™å†…å­˜å¤§å°ï¼Œæ¥é™åˆ¶é€’å½’æ·±åº¦

   ```c
   // å…¨å±€å˜é‡ï¼Œè¡¨ç¤ºé€’å½’çš„æ·±åº¦
   int depth = 0;
   int F(int n) { 
     ++depthï¼› 
     if (depth > 1000) throw exception;
     
     if (n == 1) return 1;		// ç»ˆæ­¢æ¡ä»¶
     if (n == 2) return 2;
     
     return F(n-1) * F(n-2);	// é€’æ¨å…¬å¼
   }
   ```

3. **é‡å¤è®¡ç®—**

   å¯ä»¥é€šè¿‡ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ˆæ¯”å¦‚æ•£åˆ—è¡¨ï¼‰æ¥ä¿å­˜å·²ç»æ±‚è§£è¿‡çš„å€¼

   ```c
   // ä»¥ä¸‹ F(2) è¢«é‡å¤è®¡ç®—äº†
   // F(3) = F(2) + F(1)
   // F(4) = F(3) + F(2)
   int F(int n) {
     if (n == 1) return 1;
     if (n == 2) return 2;
     
     // hasSolvedList å¯ä»¥ç†è§£æˆä¸€ä¸ª Mapï¼Œkey æ˜¯ nï¼Œvalue æ˜¯ F(n)
     if (hasSolvedList.containsKey(n)) {
       return hasSolvedList.get(n);
     }
     
     int ret = f(n-1) + f(n-2);
     hasSolvedList.put(n, ret);
     
     return ret;
   }
   ```

   

<u>æ ¹æ®å¼€å‘æ‰€é¢ä¸´çš„å…·ä½“é—®é¢˜</u>ï¼Œå¯ä»¥å°†é€’å½’è½¬æ¢ä¸º**è¿­ä»£å¾ªç¯**çš„æ–¹å¼

1. é“¾è¡¨ã€äºŒå‰æ ‘ç›¸å…³çš„é—®é¢˜å¯ä»¥ç”¨é€’å½’æ¥å®ç°

2. ç”¨è¿­ä»£å¾ªç¯æ¥æ›¿ä»£é€’å½’å¹¶ä¸èƒ½é¿å…é€’å½’åŸæœ‰çš„ç¼ºé™·

3. è¿­ä»£å¾ªç¯æœ¬è´¨ä¸Šä¸é€’å½’çš„æ–¹æ³•æ²¡æœ‰ä»»ä½•åŒºåˆ«
   ä½†å…·ä½“ç»†èŠ‚ä¸ºæ‰‹åŠ¨å®ç°ï¼Œä½¿**è¿­ä»£å¾ªç¯æ¯”é€’å½’æ›´å…·æœ‰å¯æ§æ€§**

   ```c
   int F(int n) {
     // ç»ˆæ­¢æ¡ä»¶
     if (n == 1) return 1;
     if (n == 2) return 2;
     
     // åŸé€’å½’æ ˆæ‰€éœ€è¦å­˜å‚¨çš„æ•°æ®
     int ret = 0;					
     int pre = 2;
     int prepre = 1;
     
     // é€’å½’ä½“
     for (int i = 3; i <= n; ++i) {
       ret = pre + prepre;
       prepre = pre;
       pre = ret;
     }
     
     return ret;
   }
   ```





# äºŒã€æ’åº

**ç¨³å®šæ’åº**ï¼šç›¸åŒçš„æ•°å­—æ’åºåé¡ºåºä¸å˜

**æœ‰åºåº¦**ï¼šæœ‰åºå…³ç³»çš„å…ƒç´ å¯¹çš„ä¸ªæ•°
				ä¾‹ åºåˆ— 3ï¼Œ1ï¼Œ5ï¼Œ6 ä¸­ï¼Œæœ‰åºåº¦ä¸º 5ï¼Œæœ‰åºå…³ç³»å…ƒç´ å¯¹ä¸º (3, 5) (3,6) (1,5) (1,6) (5,6)
**é€†åºåº¦**ï¼š æ»¡æœ‰åºåº¦ - æœ‰åºåº¦
**æ»¡æœ‰åºåº¦**ï¼šåºåˆ—å…¨éƒ¨é¡ºåºæ’åˆ—æ—¶çš„æœ‰åºåº¦ï¼Œè®¡ç®—å…¬å¼ ${n(n-1) \over 2}$



## 1. æ¯”è¾ƒæ’åº
### 1.1 å†’æ³¡æ’åº

![](./images/sort_bubble.png)

æ¯æ¬¡ç¡®ä¿å›ºå®šåæ®µåŒºé—´ï¼ˆå†’æ³¡ä¸Šå»çš„ï¼‰é¡ºåºæ˜¯æ­£ç¡®çš„ï¼Œä¸æ–­ç¼©å°æ’åºèŒƒå›´

- ç¨³å®šæ’åº
- ç©ºé—´å¤æ‚åº¦ $O(1)$
- æ—¶é—´å¤æ‚åº¦ï¼Œ**å–å†³äºé€†åºåº¦çš„æ•°é‡**
  æœ€å¥½ $O(n)$
  æœ€å $O(n^2)$

```c
// å†’æ³¡æ’åºï¼Œaè¡¨ç¤ºæ•°ç»„ï¼Œnè¡¨ç¤ºæ•°ç»„å¤§å°
void bubble_sort(int* arr, int n)
{
	if (n <= 1) return;
  
  for (int i = 0; i < n; ++i) {
  	bool flag = false;	// æå‰é€€å‡ºå†’æ³¡å¾ªç¯çš„æ ‡å¿—ä½
    for (int j = 0; j < n - 1 - i; ++j) {
      if (arr[j] > arr[j+1]) {
        int tmp = arr[j];	// äº¤æ¢
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
        flag = true;    // è¡¨ç¤ºæœ‰æ•°æ®äº¤æ¢
      }
    } // for j
    
    if (!flag) break;		// æ²¡æœ‰æ•°æ®äº¤æ¢ï¼Œæå‰é€€å‡º
    
  } // for i
  
}
```



### 1.2 æ’å…¥æ’åº

![](./images/sort_insert.jpg)

åŒºåˆ†å·²æ’åºåŒºé—´å’Œæœªæ’åºåŒºé—´ï¼Œæ¯æ¬¡å°†æœªæ’åºåŒºé—´çš„ç¬¬ä¸€å…ƒç´ æ’å…¥åˆ°å·²æ’åºåŒºé—´

- ç¨³å®šæ’åº
- ç©ºé—´å¤æ‚åº¦ $O(1)$
- æ—¶é—´å¤æ‚åº¦ï¼Œ**å–å†³äºé€†åºåº¦çš„æ•°é‡**
  æœ€å¥½ $O(n)$
  æœ€å $O(n^2)$

```c
// æ’å…¥æ’åºï¼Œaè¡¨ç¤ºæ•°ç»„ï¼Œnè¡¨ç¤ºæ•°ç»„å¤§å°
void insertion_sort(int* arr, int n)
{
  if (n <= 1) return;
  
  for (int i = 1; i < n; ++i) {
    int tmp = arr[i];
    int j = i - 1; 		// æŸ¥æ‰¾æ’å…¥çš„ä½ç½®
    for (; j >= 0; --j) {
      if (arr[j] > tmp) {
        arr[j+1] = arr[j];// è¿™é‡Œç›¸æ¯”äºå†’æ³¡æ’åºåªè¿›è¡Œäº†ä¸€æ¬¡èµ‹å€¼ï¼Œæ‰€ä»¥æ’å…¥æ’åºæ¯”å†’æ³¡æ’åºæ›´é«˜æ•ˆ
      } else {
        break;
      }
    }
    arr[j+1] = tmp; 		// æ’å…¥æ•°æ®
  }
  
}
```



### 1.3 é€‰æ‹©æ’åº

![](./images/sort_selection.jpg)

åŒºåˆ†å·²æ’åºåŒºé—´å’Œæœªæ’åºåŒºé—´ï¼Œæ¯æ¬¡å°†æœªæ’åºåŒºé—´ä¸­æ‰¾åˆ°æœ€å°çš„å…ƒç´ ï¼Œå°†å…¶æ”¾åˆ°å·²æ’åºåŒºé—´çš„æœ«å°¾

- ä¸æ˜¯ç¨³å®šæ’åº
- ç©ºé—´å¤æ‚åº¦ $O(1)$
- æ—¶é—´å¤æ‚åº¦è¾ƒç¨³å®šï¼Œæœ€å¥½æœ€åéƒ½æ˜¯ $O(n^2)$

```c
// é€‰æ‹©æ’åºï¼Œaè¡¨ç¤ºæ•°ç»„ï¼Œnè¡¨ç¤ºæ•°ç»„å¤§å°
void selection_sort(int* arr, int n)
{
  if (n <= 1) return;
  
  for (int i = 0; i < n - 1; ++i) {
    int min = i;
    for (int j = i + 1; j < n; ++j) {
      if (arr[min] > arr[j]) {
        min = j;
      }
    } // for j
    
    if (min != i) {
    	std::swap(arr[i], arr[min]);    
		}
  } // for i
  
}
```



### 1.4 å½’å¹¶æ’åº

![](./images/sort_merge.png)

é‡‡ç”¨åˆ†è€Œæ²»ä¹‹çš„æ€æƒ³ï¼Œå…ˆå°†åºåˆ—äºŒåˆ†ï¼Œç›´åˆ°ä¸èƒ½äºŒåˆ†ä¸ºæ­¢ï¼Œåé€šè¿‡åˆå¹¶åºåˆ—çš„æ–¹æ³•æ¥æ’åº

- ç¨³å®šæ’åº

- ç©ºé—´å¤æ‚åº¦ $O(n)$

- æ—¶é—´å¤æ‚åº¦è¾ƒç¨³å®šï¼Œæœ€å¥½æœ€åéƒ½æ˜¯ $O(nlogn)$
  ç”±ä¸‹é¢çš„æ¨è®ºå¯çŸ¥ï¼Œå½’å¹¶æ’åºç»è¿‡ ${n \over 2^k}$ æ¬¡åˆ†è§£æ‰å˜ä¸º 1ï¼Œå› æ­¤ $k = log_2n$ åˆ™ $T(n) = nlog_2n$
  $$
  \begin{align}
  T(1) &= C \\
  T(n) &= 2*T({n \over 2}) \\
  		 &= 2*(2*T({n \over 4}))  &= 4*T({n \over 4}) \\
       &= 4*(2*T({n \over 8}))  &= 8*T({n \over 8}) \\
       &= 2^k * T({n \over 2^k}) \\
  \end{align}
  $$

```c
void merge_sort(int* arr, int arrLength)
{
  __merge_sort(arr, 0, arrLength-1);
}

// é€’å½’è°ƒç”¨å‡½æ•°
void __merge_sort(int* arr, int start, int end)
{
  // é€’å½’ç»ˆæ­¢æ¡ä»¶
  if (start >= end) return;  
  
  int middle = (start + end) / 2;
    
  // åˆ†æ²»é€’å½’
  __merge_sort(arr, middle, 		start);
  __merge_sort(arr, middle + 1, end);
  
  // è§£å†³é—®é¢˜ï¼Œåˆå¹¶ç»“æœ
  __merge(arr, start, middle, end);
}

void __merge(int* arr, int start, int middle, int end)
{
  const int size = end - start + 1;
  int tmp[size];
	int i = start;
  int j = middle + 1;
  int k = 0;
  // æ¯”è¾ƒå‰åä¸¤éƒ¨åˆ†å…ƒç´ ï¼Œä»å°åˆ°å¤§æ’åˆ—åœ¨ tmp æ•°ç»„é‡Œ
	while (i <= middle && j <= end) {
		if (arr[i] <= arr[j])
			tmp[++k] = arr[++i];
		else
			tmp[++k] = arr[++j];
	}
  
  // å¦‚æœå‰åŠéƒ¨åˆ†å‰©ä¸‹ï¼Œcopy åˆ°ç¼“å­˜æ•°ç»„
  while (i <= middle) {
    tmp[++k] = arr[++i];
  }
  // å¦‚æœååŠéƒ¨åˆ†å‰©ä¸‹ï¼Œcopy åˆ°ç¼“å­˜æ•°ç»„
  while (j <= end) {
    tmp[++k] = arr[++j];
  }

  // å°†æ’å¥½åºçš„æ•°ç»„ copy å›åŸæ•°ç»„
	memcpy(&(arr[start]), &(tmp[0]), size * sizeof(int));
}
```



### 1.5 å¿«é€Ÿæ’åº

![](./images/quick_sort.png)

é‡‡ç”¨åˆ†è€Œæ²»ä¹‹çš„æ€æƒ³ï¼Œåœ¨åºåˆ—ä¸­é€‰æ‹©ä»»æ„ä¸€ä¸ªæ•°ä¸ºåˆ†åŒºç‚¹ï¼ˆPivotï¼‰ï¼Œéå†å½“å‰åºåˆ—ï¼Œå°†å°äºåˆ†åŒºç‚¹çš„æ•°æ®æ”¾åœ¨å…¶å‰é¢ï¼Œå¤§äºåˆ†åŒºç‚¹çš„æ•°æ®æ”¾åœ¨å…¶åé¢ï¼Œä¹‹åå‰ååˆ†åŒºé‡æ–°é€‰æ‹©æ–°çš„åˆ†åŒºç‚¹ï¼Œä¸æ–­ç»†åˆ†ï¼Œæœ€ååˆ°ä¸èƒ½åˆ’åˆ†åï¼Œæ’åºå®Œæˆ

- ä¸æ˜¯ç¨³å®šæ’åº

- ç©ºé—´å¤æ‚åº¦ $O(1)$

- æ—¶é—´å¤æ‚åº¦
  æœ€å¥½ $O(nlogn)$
  æœ€å $O(n^2)$ ï¼ˆåŒºåˆ†ç‚¹é€‰æ‹©ä¸å½“ï¼‰



ä¼˜åŒ–ï¼Œä¸»è¦æ˜¯ä¼˜åŒ–åŒºåˆ†ç‚¹çš„é€‰æ‹©

1. ä¸‰æ•°å–ä¸­
   ä»åŒºé—´çš„é¦–ã€å°¾ã€ä¸­é—´ï¼Œåˆ†åˆ«å–å‡ºä¸€ä¸ªæ•°ï¼Œç„¶åå¯¹æ¯”å¤§å°ï¼Œå–è¿™ 3 ä¸ªæ•°çš„ä¸­é—´å€¼ä½œä¸ºåˆ†åŒºç‚¹
2. éšæœºæ³•
   æ¯æ¬¡ä»è¦æ’åºçš„åŒºé—´ä¸­ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªå…ƒç´ ä½œä¸ºåˆ†åŒºç‚¹

```c
void quick_sort(int *arr, int size)
{
	__quick_sort(arr, 0, size - 1);
}

void __quick_sort(int *arr, int p, int r)
{
	if (p >= r) return;

	int q = partition(arr, p, r);
	__quick_sort(arr, p, q-1);
	__quick_sort(arr, q+1, r);
}

int partition(int *arr, int p, int r)
{
	int i; // å°†æ•°ç»„åˆ†ä¸º < i çš„å·²å¤„ç†åŒºï¼Œå’Œ >= i çš„æœªå¤„ç†åŒº
  int j; // æŒ‡å‘æœªå¤„ç†åŒºç¬¬ä¸€ä¸ªå…ƒç´ 
	for (i = j = p; j < r; ++j) {
		if (arr[j] < arr[r]) { 									// è®¾ pivot = arr[r]
			if(i != j) std::swap(arr[i], arr[j]); // ä¸ºé¿å…æ’å…¥æ•°æ®åçš„ç§»åŠ¨ï¼Œè¿™é‡Œä½¿ç”¨äº¤æ¢
      
			++i;																	// é‡åˆ° > pivot çš„æ•°å°±åœä½ï¼Œç­‰å¾…äº¤æ¢
		}
	}
	
	std::swap(arr[i], arr[r]);
  
	return i;
}
```



### 1.6 å †æ’åº

åˆ©ç”¨å †è¿™ä¹ˆä¸€ä¸ªé€»è¾‘ä¸Šçš„å®Œå…¨äºŒå‰æ ‘ç»“æ„ï¼Œè€Œå­˜å‚¨ä¸Šç”¨æ•°ç»„è¿™ä¸ªæ•°æ®ç»“æ„æ¥è¿›è¡Œæ’åº

- ä¸æ˜¯ç¨³å®šæ’åº
- ç©ºé—´å¤æ‚åº¦ $O(1)$
- æ—¶é—´å¤æ‚åº¦ï¼Œæœ€å¥½ï¼Œæœ€åéƒ½æ˜¯ $O(nlogn)$
- **å †æ“…é•¿å–æ•°æ®çš„å‰å‡ ä¸ªå€¼ï¼Œè€Œä¸æ˜¯å°†æ•´ä¸ªæ•°æ®æ’åº**
- å †æ“…é•¿å–**åŠ¨æ€å˜åŒ–æ•°æ®**çš„å‰å‡ ä¸ªå€¼



å¯¹æ¯”äºå¿«é€Ÿæ’åºï¼Œå †æ’åºæ€§èƒ½è¾ƒå·®

1. å †æ’åºè®¿é—®æ•°æ®æ˜¯è·³ç€è®¿é—®çš„ï¼Œå¿«é€Ÿæ’åºæ˜¯é¡ºåºè®¿é—®çš„ï¼Œè·³ç€è®¿é—®å¦‚æœå¹…åº¦è¿‡å¤§å¯èƒ½ä¼šå¯¼è‡´ CPU ç¼“å­˜çš„ä¸æ–­æ›´æ¢ï¼Œä»è€Œé™ä½æ€§èƒ½
2. åŒæ ·çš„æ•°æ®å †æ’åºè¿›è¡Œçš„äº¤æ¢æ¬¡æ•°æ¯”å¿«é€Ÿæ’åºå¤š



æ­¥éª¤

1. **å»ºå †**ï¼šæ—¶é—´å¤æ‚åº¦ $O(n)$
   å°†æ•°ç»„åŸåœ°å»ºæˆä¸€ä¸ªå †ï¼ˆä¸å€ŸåŠ©å…¶ä»–æ•°ç»„ï¼‰
   <u>æ–¹æ³•ä¸€ï¼šä»å‰åˆ°å</u>
   å°½ç®¡å †æ•°ç»„ä¸­åŒ…å« n ä¸ªæ•°æ®ï¼Œä½†å¯ä»¥å‡è®¾ï¼Œèµ·åˆå †ä¸­åªåŒ…å«ä¸€ä¸ªæ•°æ®ï¼Œå°±æ˜¯ä¸‹æ ‡ä¸º 1 çš„æ•°æ®ã€‚ç„¶åå°†å‰©ä¸‹çš„æ•°æ®é€ä¸ªæ’å…¥å †ä¸­
   <u>æ–¹æ³•äºŒï¼šä»ååˆ°å‰</u>
   ä»ååˆ°å‰å°†å †èŠ‚ç‚¹å…¨éƒ¨éå†å †åŒ–ï¼Œå‡å°‘æ–¹æ³•ä¸€ä¸­**å †åŒ–ä¸æ–­ä»å‰åˆ°å**çš„**é‡å¤éå†**

2. **å †åŒ–**
   ä»ä¸Šåˆ°ä¸‹ï¼ˆæˆ–ä»ä¸‹åˆ°ä¸Šï¼‰å°†æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰æ”¾åˆ°å †çš„æ ¹ç›®å½•ï¼Œæ„å»ºæœ‰åºçš„å †

3. **æ’åº**ï¼šä»åå‘å‰

   1. äº¤æ¢å †é¡¶å’Œå †æœ€åä¸€ä¸ªæ•°

   2. å †<u>é€»è¾‘ä¸Šåˆ é™¤</u>å †æœ€åä¸€ä¸ªæ•°ï¼ˆå †çš„èŒƒå›´å‡å°ï¼‰

   3. å †åŒ–

   4. é‡å¤ 1 ï½ 3 æ­¥éª¤ï¼Œç›´åˆ°å †çš„èŒƒå›´ç¼©å°ä¸º 1ï¼Œå †æ’åºç»“æŸ

      ![](./images/sort_heap.jpg)

```c++
// å»ºå †ï¼šä»ååˆ°å‰
// è¿™é‡Œçš„ a é»˜è®¤ç»“æ„æ˜¯ä» 1 å¼€å§‹å­˜å‚¨çš„æ•°ç»„ï¼Œä¸åŒäºæ•°ç»„ a çš„é•¿åº¦ï¼Œn è¡¨ç¤ºæ•°æ®çš„ä¸ªæ•°
void buildHeap(int* a, int n) {
  // å¯¹äºå †è¿™æ ·çš„å®Œå…¨äºŒå‰æ ‘ç»“æ„ç¬¬ n/2+1 ï½ n éƒ½æ˜¯å¶å­èŠ‚ç‚¹
  // å †åŒ–æ—¶ä¼šè®¿é—®ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ï¼Œå› æ­¤è¿™é‡Œä¸éœ€è¦å¯¹æœ€åº•å±‚çš„èŠ‚ç‚¹åšå †åŒ–
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i);
  }
}

// å †åŒ–ï¼šè‡ªä¸Šå¾€ä¸‹
void heapify(int* a, int n, int i) { 
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) 					maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) 												break;
    std::swap(a[i], a[maxPos]);
    i = maxPos;
  }
}

// è¿™é‡Œçš„ a é»˜è®¤ç»“æ„æ˜¯ä» 1 å¼€å§‹å­˜å‚¨çš„æ•°ç»„ï¼Œä¸åŒäºæ•°ç»„ a çš„é•¿åº¦ï¼Œn è¡¨ç¤ºæ•°æ®çš„ä¸ªæ•°
void heap_sort(int* a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    std::swap(a[1], a[k]);
    --k;
    heapify(a, k, 1);
  }
}
```





## 2. çº¿æ€§æ’åº

æ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ï¼Œå¯¹æ’åºçš„æ•°æ®è¦æ±‚è‹›åˆ»
<u>çº¿æ€§æ’åºæ¯”è¾ƒå¼ºè°ƒæ•°æ®çš„èŒƒå›´ï¼ŒèŒƒå›´ä¸ç­‰åŒäºå¤§å°ï¼Œä¸€ç»„å¾ˆå¤§çš„æ•°ï¼Œä»–ä»¬çš„èŒƒå›´å¯ä»¥å¾ˆå°</u>

### 2.1 æ¡¶æ’åº

æŠŠå«æœ‰çš„ n ä¸ªæ•°æ®çš„æ•°ç»„ï¼Œå‡åŒ€åœ°åˆ’åˆ†åˆ° m ä¸ªæ•°ç»„ï¼ˆæ¡¶ï¼‰å†…ï¼Œæ¯ä¸ªæ•°ç»„å†…éƒ¨ä½¿ç”¨å¿«é€Ÿæ’åºï¼Œæœ€åé‡æ–°åˆå¹¶ä¸ºä¸€ä¸ªæ•°ç»„ï¼ˆå¦‚æœåˆ’åˆ†åï¼ŒæŸä¸ªæ•°ç»„çš„æ•°æ®ä»è¿‡å¤šï¼Œå¯å•ç‹¬å°†è¿™ä¸ªæ•°ç»„ç»§ç»­åˆ’åˆ†ï¼‰

- ä¸æ˜¯ç¨³å®šæ’åº
- ç©ºé—´å¤æ‚åº¦ $O(n)$
- æ—¶é—´å¤æ‚åº¦
  å¹³å‡ $O(nlog{n \over m}) = O(m * {n \over m} * log{n \over m})$
  æœ€å¥½ $O(n)$ï¼Œå½“ m å’Œ n æ¥è¿‘æ—¶



**ä½¿ç”¨æ¡¶æ’åºçš„å‰ç½®æ¡ä»¶**

1. æ•°ç»„çš„æ•°æ®å¯ä»¥è¢«å‡åŒ€çš„åˆ’åˆ†ä¸ºå‡ ä¸ªæ•°ç»„ï¼ˆæç«¯æƒ…å†µï¼Œéƒ½è¢«åˆ’åˆ†ä¸ºä¸€ä¸ªæ¡¶é‡Œï¼Œæ¡¶æ’åºä¼šé€€åŒ–ä¸ºä¸€ä¸ªå¿«é€Ÿæ’åºï¼‰

2. æ•°ç»„åˆ’åˆ†ä¸ºå‡ ä¸ªæ•°ç»„åï¼Œæ•°ç»„é—´çš„é¡ºåºè¦æ±‚å·²ç»æ’å¥½äº†ï¼Œä¸éœ€è¦æ•°ç»„é—´åœ¨é‡æ–°æ’åº

   

**é€‚ç”¨åœºæ™¯**

æ¡¶æ’åºæ¯”è¾ƒé€‚åˆç”¨åœ¨å¤–éƒ¨æ’åºä¸­
å¤–éƒ¨æ’åºå°±æ˜¯æ•°æ®å­˜å‚¨åœ¨å¤–éƒ¨ç£ç›˜ä¸­ï¼Œæ•°æ®é‡æ¯”è¾ƒå¤§ï¼Œå†…å­˜æœ‰é™ï¼Œæ— æ³•å°†æ•°æ®å…¨éƒ¨åŠ è½½åˆ°å†…å­˜ä¸­

```c++
#include <algorithm>
#include <iterator>

template <size_t BucketSize,
          typename IterT,
          typename T = typename std::iterator_traits<IterT>::value_type,
          typename Compare = std::less<T>>
void bucket_sort(IterT first, IterT last, Compare comp = Compare()) {
    const T min = *std::min_element(first, last);
    const T max = *std::max_element(first, last);
    const T range = max + 1 - min;
    const size_t bucket_num = (range - 1) / BucketSize + 1;

    std::vector<std::vector<T>> buckets(bucket_num);
    for (auto b : buckets) {
        b.reserve(2 * BucketSize);
    }

    for (IterT i = first; i != last; ++i) {
        size_t idx = (*i - min) / BucketSize;
        buckets[idx].emplace_back(*i);
    }

    IterT dest = first;
    for (auto b : buckets) {
        std::sort(b.begin(), b.end(), comp);
        std::copy(b.begin(), b.end(), dest);
        dest += b.size();
    }

    return;
}
```



### 2.2 è®¡æ•°æ’åº

![](./images/sort_counting.png)

è®¡æ•°æ’åºæ˜¯æ¡¶æ’åºçš„ç‰¹æ®Šæƒ…å†µï¼ŒæŠŠå«æœ‰çš„ n ä¸ªæ•°æ®çš„æ•°ç»„ï¼Œå‡åŒ€åœ°åˆ’åˆ†åˆ° m ä¸ªæ•°ç»„ï¼ˆæ¡¶ï¼‰å†…ï¼Œ**æ¯ä¸ªæ•°ç»„å†…éƒ¨çš„æ•°æ®éƒ½ç›¸åŒ**

- ç¨³å®šæ’åºï¼ˆå¿…é¡»ä»åå‘å‰éå†ï¼‰
- ç©ºé—´å¤æ‚åº¦ $O(n)$
- æ—¶é—´å¤æ‚åº¦ $O(n)$



**ä½¿ç”¨è®¡æ•°æ’åºçš„å‰ç½®æ¡ä»¶**

1. åªèƒ½ç”¨åœ¨æ•°æ®èŒƒå›´ä¸å¤§çš„åœºæ™¯ä¸­ï¼Œå¦‚æœæ•°æ®èŒƒå›´ k æ¯”è¦æ’åºçš„æ•°æ®ä¸ªæ•° n å¤§å¾ˆå¤šï¼Œä¸é€‚åˆç”¨è®¡æ•°æ’åº
2. åªèƒ½ç»™éè´Ÿæ•´æ•°æ’åºï¼Œå¦‚æœè¦æ’åºçš„æ•°æ®æ˜¯å…¶ä»–ç±»å‹çš„ï¼Œè¦å°†å…¶åœ¨ä¸æ”¹å˜ç›¸å¯¹å¤§å°çš„æƒ…å†µä¸‹ï¼Œè½¬åŒ–ä¸ºéè´Ÿæ•´æ•°



**é€‚ç”¨åœºæ™¯**

æ’åºçš„æ•°æ®èŒƒå›´å°

```c++
#include <algorithm>
#include <iterator>

template <typename IterT,
          typename T = typename std::iterator_traits<IterT>::value_type>
void counting_sort(IterT first, IterT last) {
    const auto len = std::distance(first, last);
    if (len < 2) return;

    const T max = *std::max_element(first, last);
    if (max == 0) return;

    std::vector<size_t> counter(max + 1);
    // è®°å½•æ¯ä¸ªæ•°å¯¹åº”çš„ä¸ªæ•°
    for (IterT i = first; i != last; ++i) {
        ++counter[*i];
    }
    // è®°å½•å°äºå½“å‰æ•°çš„ä¸ªæ•°
    for (size_t i = 1; i < counter.size(); ++i) {
        counter[i] += counter[i - 1];
    }

    std::vector<T> temp(len);
    // æ ¹æ®è®¡æ•°è¡¨ï¼Œä»åå‘å‰éå†åŸæ•°ç»„ï¼ˆç¡®ä¿ç¨³å®šæ’åºï¼‰ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„æ’åºåçš„æ•°ç»„
    for (IterT i = last - 1; i >= first; --i) {
        temp[counter[*i] - 1] = *i;
        --counter[*i];
    }
    std::copy(temp.begin(), temp.end(), first);
}

// æµ‹è¯•å‡½æ•°
template <typename Container,
          typename T = typename Container::value_type>
void test_counting_sort(Container cont) {
    counting_sort(cont.begin(), cont.end());
    std::transform(cont.begin(), 
                   cont.end(), 
                   std::ostream_iterator<T>(std::cout, " "),
                   [](T i){ return i; });
    std::cout << std::endl;
}
```



### 2.3 åŸºæ•°æ’åº

![](./images/radix_sort.jpg)

åœ¨ä¸€äº›è¾ƒå¤§çš„æ•°ç»„æˆçš„æ•°ç»„é‡Œï¼Œé€šè¿‡**é€ä¸ªæ¯”è¾ƒ**ä¸åŒæ•°åŒä¸€ä½æ•°å­—ï¼ˆåŸºæ•°ï¼‰çš„å¤§å°æ¥è¿›è¡Œæ’åº

- ç¨³å®šæ’åºï¼ˆå¿…é¡»ä»åå‘å‰éå†ï¼‰
- ç©ºé—´å¤æ‚åº¦ $O(1)$
- æ—¶é—´å¤æ‚åº¦ $O(n) = O(C_{ä½æ•°} * n)$



**ä½¿ç”¨åŸºæ•°æ’åºçš„å‰ç½®æ¡ä»¶**

1. æ•°ç»„é‡Œçš„æ•°æ®å¯ä»¥æŒ‰ä½åˆ’åˆ†
2. ä½ä¹‹é—´æœ‰é€’è¿›çš„å…³ç³»
   å¦‚æœ a æ•°æ®çš„é«˜ä½æ¯” b æ•°æ®å¤§ï¼Œé‚£å‰©ä¸‹çš„ä½ä½å°±ä¸ç”¨æ¯”è¾ƒäº†
3. æ¯ä¸€ä½çš„æ•°æ®**èŒƒå›´**ä¸èƒ½å¤ªå¤§ï¼Œè¦å¯ä»¥ç”¨çº¿æ€§æ’åºç®—æ³•æ¥æ’åº



**é€‚ç”¨åœºæ™¯**

- å•è¯åœ¨å­—å…¸ä¸­çš„æ’åº
  æ‰€æœ‰çš„å•è¯è¡¥é½åˆ°ç›¸åŒé•¿åº¦ï¼Œä½æ•°ä¸å¤Ÿçš„å¯ä»¥åœ¨åé¢è¡¥ 0
  ASCII å€¼æ‰€æœ‰å­—æ¯å¤§äº 0ï¼Œè¡¥ 0 ä¸ä¼šå½±å“åŸæœ‰çš„é¡ºåº
- æ‰‹æœºå·æ’åº
  æ‰‹æœºå·è¦æ˜¯çœ‹ä½œä¸€ä¸ªæ•°çš„è¯ï¼Œå³ä¾¿ä½æ•°è¦ç›¸åŒï¼Œæ•°æ®çš„èŒƒå›´ä¼šå¾ˆå¤§
  ä½¿ç”¨åŸºæ•°æ’åºï¼Œä¼šç»†åˆ†æ‰‹æœºå·çš„åˆ†å¸ƒèŒƒå›´ï¼Œä»è€Œæé«˜æ’åºæ•ˆç‡

```c++
#include <math.h>

void radix_sort(int a[], int len, int digit_max)
{
	int *tmp = (int *)std::malloc(sizeof(int)*len);
	assert(nullptr != tmp);

  int digit = 1;
	int counter[10];
	for (int i = 0, j = 0, k = 0; i < digit_max; ++i) {
    memset(counter, 0, sizeof(int)*10);
    
    // ä»åå‘å‰éå†åŸæ•°çš„ä½æ•°ï¼ˆç¡®ä¿ç¨³å®šæ’åºï¼‰
    digit = pow(10, i);
    
    for (j = 0; j < len; ++j) {
			k = (a[j] / digit) % 10;
			++counter[k];
		}
		for(j = 1; j < 10; ++j) {
			counter[j] += counter[j-1];
		}

    // ä»åå‘å‰éå†åŸæ•°ç»„ï¼ˆç¡®ä¿ç¨³å®šæ’åºï¼‰
		for(j = len - 1; j >= 0; --j) {
			k = (a[j] / digit) % 10;
      tmp[counter[k] - 1] = a[j];
			--counter[k];
		}
    
    memcpy(a, tmp, sizeof(int)*len);
	}

}
```



# ä¸‰ã€æœç´¢æ•°æ®

ä¸åŒçš„æ•°æ®ç»“æ„ï¼Œé€‚åˆä¸åŒçš„æ•°æ®æŸ¥æ‰¾æ–¹å¼



## 1. äºŒåˆ†æŸ¥æ‰¾ï¼ˆä¾èµ–æ•°ç»„ï¼‰

ç©ºé—´å¤æ‚åº¦ $O(1)$

æ—¶é—´å¤æ‚åº¦ $O(logn)$
å…¶ä¸­ ${n \over 2^k}=1$ æ—¶ï¼Œk çš„å€¼å°±æ˜¯æ€»å…±ç¼©å°çš„æ¬¡æ•°ï¼Œå³æ—¶é—´å¤æ‚åº¦



### 1.1 ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„å‰ç½®æ¡ä»¶

- æŸ¥æ‰¾æ•°æ®å·²ç»**æœ‰åº**
- äºŒåˆ†æŸ¥æ‰¾**ä¾èµ–äºæ•°ç»„**è¿™ç§è¿ç»­å†…å­˜çš„æ•°æ®ç»“æ„
- ç”±äºè¿ç»­å†…å­˜çš„å­˜å‚¨ç»“æ„ï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„æ•°é‡ä¸å®œå¤ªå¤§æˆ–è€…å¤ªå°

```c++
// 1. ç®€å•çš„äºŒåˆ†æŸ¥æ‰¾å®ç°ï¼ˆæ•°æ®å·²ç»æ’å¥½åºï¼Œä¸”æ•°æ®ä¸é‡å¤ï¼‰
// 1.1 å¾ªç¯å®ç°
int binary_search(int* a, int n, int value) {
  int low = 0; 
  int high = n - 1;
  while (low <= high) {
    // ä¸ºé˜²æ­¢ç›¸åŠ å¸¦æ¥çš„è¿‡å¤§æ•°æ®ç§»é™¤ï¼Œå¯ä¼˜åŒ–ä¸ºï¼šlow + (high - low) / 2
    int mid = (low + high) / 2;
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  
  return -1;
}

// 1.2 é€’å½’å®ç°
int __binary_search(int* a, int low, int high, int value) {
  if (low > high) return -1;
  
  int mid = low + ((high - low) >> 1);
  if (a[mid] == value) {
    return mid;
  } else if (a[mid] < value) {
    return __binary_search(a, mid+1, high, value);
  } else {
    return __binary_search(a, low,  mid-1, value);
  }
}

int bsearch(int* a, int n, int val) {
  return __binary_search(a, 0, n - 1, val);
}

// 2. è€ƒè™‘é‡å¤æƒ…å†µçš„äºŒåˆ†æŸ¥æ‰¾ï¼ˆæ•°æ®å·²ç»æ’å¥½åºï¼Œä¸”æ•°æ®å«æœ‰å¤šä¸ªé‡å¤çš„æ•°ï¼‰
// 2.1 æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå€¼ç­‰äºç»™å®šå€¼çš„å…ƒç´ 
int bsearch(int* a, int n, int val) {
  int low = 0;  
  int high = n - 1;  
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] > val) {
      high = mid - 1;
    } else if (a[mid] < val) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != val)) return mid;
      else high = mid - 1;   // ç”±äºæ˜¯æ‰¾å¯èƒ½é‡å¤æ•°çš„ç¬¬ä¸€ä¸ªï¼Œè¿™é‡Œä¸æ–­å–å‰åŠæ®µæ•°æ®
    }
  }
  
  return -1;
}

// 2.2 æŸ¥æ‰¾æœ€åä¸€ä¸ªå€¼ç­‰äºç»™å®šå€¼çš„å…ƒç´ 
int bsearch(int* a, int n, int val) {
  int low = 0;  
  int high = n - 1;  
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] > val) {
      high = mid - 1;
    } else if (a[mid] < val) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != val)) return mid;
      else low = mid + 1;   // ç”±äºæ˜¯æ‰¾å¯èƒ½é‡å¤æ•°çš„æœ€åä¸€ä¸ªï¼Œè¿™é‡Œä¸æ–­å–ååŠæ®µæ•°æ®
    }
  }
  
  return -1;
}

// 2.3 æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äºç­‰äºç»™å®šå€¼çš„å…ƒç´ 
int bsearch(int* a, int n, int val) {
  int low = 0;  
  int high = n - 1;  
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] >= val) {
      if ((mid == 0) || (a[mid - 1] < val)) return mid;
      else high = mid - 1;   // ç”±äºæ˜¯æ‰¾å¯èƒ½é‡å¤æ•°çš„ç¬¬ä¸€ä¸ªï¼Œè¿™é‡Œä¸æ–­å–å‰åŠæ®µæ•°æ®
    } else {
      low = mid + 1;
    }
  }
  
  return -1;
}

// 2.4 æŸ¥æ‰¾æœ€åä¸€ä¸ªå°äºç­‰äºç»™å®šå€¼çš„å…ƒç´ 
int bsearch(int* a, int n, int val) {
  int low = 0;  
  int high = n - 1;  
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] > val) {
      high = mid - 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] > val)) return mid;
      else low = mid + 1;   // ç”±äºæ˜¯æ‰¾å¯èƒ½é‡å¤æ•°çš„æœ€åä¸€ä¸ªï¼Œè¿™é‡Œä¸æ–­å–ååŠæ®µæ•°æ®
    }
  }
  
  return -1;
}
```



### 1.2 äºŒåˆ†æŸ¥æ‰¾é€‚ç”¨åœºæ™¯

- äºŒåˆ†æŸ¥æ‰¾æ›´é€‚åˆç”¨åœ¨æŸ¥æ‰¾è¿‘ä¼¼å€¼çš„é—®é¢˜
- å¯¹äºç»™å®šå€¼çš„æŸ¥æ‰¾ï¼Œç”¨æ•£åˆ—è¡¨æˆ–è€…äºŒå‰æ ‘æ¯”äºŒåˆ†æŸ¥æ‰¾æ›´å¥½

```c++
// åº”ç”¨ä¸¾ä¾‹ï¼š
// 1. æŸ¥æ‰¾ IP åœ¨æŸä¸€ä¸ª IP èŒƒå›´å†…ï¼Œç¡®å®šå½’å±åœ°ï¼ˆäºŒåˆ†æŸ¥æ‰¾æœ€åä¸€ä¸ªå°äºç­‰äºç»™å®šå€¼çš„å…ƒç´ ï¼‰
// 2. æ±‚æ•°çš„å¹³æ–¹æ ¹ï¼ˆåœæ­¢äºŒåˆ†æŸ¥æ‰¾çš„ä¾æ®æ˜¯ä¸€ä¸ªç²¾åº¦èŒƒå›´ï¼‰
double sqrt(double x, double precision) {
	if (x < 0) return NAN;
	
	double low = 0;
	double high = x;
	if (x < 1 && x > 0) {
		low = x;
		high = 1;
	}
  
  double mid = low + ((up - high) >> 1);
	while((high - low) > precision) {
    // mid * mid è¿™é‡Œå¯èƒ½ä¼šæº¢å‡º
		if (mid * mid > x ) {
			high = mid;
		} else if (mid * mid < x) {
			low = mid;
		} else {
			return mid;
		}
    mid = low + ((up - high) >> 1);
	}
  
	return mid;
}
```



## 2. æ‹“æ‰‘æ’åº Topological





## 3. Dijkstra å•æºæœ€çŸ­è·¯å¾„ç®—æ³•



## 4. A* å•æºæœ€çŸ­è·¯å¾„ç®—æ³•







# å››ã€å­—ç¬¦ä¸²åŒ¹é…

## 1. å•æ¨¡å¼ä¸²åŒ¹é…

ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆä¸»ä¸²ï¼‰æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆæ¨¡å¼ä¸²ï¼‰

### 1.1 BFï¼ˆBrute Forceï¼‰æš´åŠ›/æœ´ç´ åŒ¹é…ç®—æ³•

æ–¹æ³•ï¼šåœ¨ä¸»ä¸²ä¸­ï¼Œä»èµ·å§‹ä½ç½®å¼€å§‹æ£€æŸ¥åç»­çš„ä½ç½®æ˜¯å¦å’Œæ¨¡å¼ä¸²ä¸€ä¸€å¯¹åº”ï¼Œå¦‚æœä¸æ˜¯ï¼Œä»èµ·å§‹ä½ç½®çš„åä¸€ä½é‡æ–°å¼€å§‹æ˜¯æ£€æŸ¥ï¼Œç›´åˆ°ç¬¬ n - m + 1 ä½ä¸ºæ­¢

- æ—¶é—´å¤æ‚åº¦ï¼šæœ€å $O(n_{ä¸»ä¸²é•¿åº¦}*m_{æ¨¡å¼ä¸²é•¿åº¦})$
- ç»Ÿè®¡æ„ä¹‰ä¸Šï¼Œåœ¨ä¸»ä¸²å’Œæ¨¡å¼ä¸²**ä¸ç®—å¤ªé•¿**çš„æƒ…å†µä¸‹æ•ˆç‡é«˜
- ç®—æ³•å®ç°ç®€å•ï¼Œåœ¨å·¥ç¨‹ä¸­ï¼Œåœ¨æ»¡è¶³æ€§èƒ½è¦æ±‚çš„å‰æä¸‹ï¼Œç®€å•æ˜¯é¦–é€‰
  æ»¡è¶³ KISSï¼ˆKeep It Simple and Stupidï¼‰è®¾è®¡åŸåˆ™

```c++
/** BF æ–¹æ³•ç¤ºä¾‹ï¼š
	i = 0
	b a d d e f ä¸»ä¸²
	a b c				æ¨¡å¼ä¸²
	
		i = 1
	b a d d e f ä¸»ä¸²
		a b c			æ¨¡å¼ä¸²
		
	    i = 2
	b a d d e f ä¸»ä¸²
			a b c	  æ¨¡å¼ä¸²
			
	      i = 3
	b a d d e f ä¸»ä¸²
				a b c	æ¨¡å¼ä¸²
 */
bool isMatch(const char* strMain, int start, const char* strPattern, int lenPattern) {
  int j = 0;
  while (j < lenPattern) {
    if (strMain[j + start] != strPattern[j]) break;
    ++j;
  }
  
  return (j == lenPattern);
}

int findBF(const char* strMain, const char* strPattern) {
  const int lenMain = std::strlen(strMain);
  const int lenPattern = std::strlen(strPattern);
  
  if (lenMain < lenPattern) return -1;
  
  for (int i = 0; i < lenMain - lenPattern + 1; ++i) {
     if (isMatch(strMain, i, strPattern, lenPattern)) return i;
  }
  
  return -1;
}
```



### 1.2 RK ç®—æ³•

> RKï¼ˆRabin-Karpï¼‰æ˜¯å‘æ˜å®ƒçš„ä¸¤ä¸ªä½œè€…åå­—çš„ç¼©å†™

æ–¹æ³•ï¼šé€šè¿‡å“ˆå¸Œç®—æ³•å¯¹ä¸»ä¸²ä¸­çš„ n-m+1 ä¸ªå­ä¸²åˆ†åˆ«æ±‚å“ˆå¸Œå€¼ï¼Œç„¶åé€ä¸ªä¸æ¨¡å¼ä¸²çš„å“ˆå¸Œå€¼æ¯”è¾ƒå¤§å°ï¼Œç›¸ç­‰åˆ™æ‰¾åˆ°

```c++
bool isMatch(const char* strMain, int start, const char* strPattern, int lenPattern) {
  int j = 0;
  while (j < lenPattern) {
    if (strMain[j + start] != strPattern[j]) break;
    ++j;
  }
  return (j == lenPattern);
}

// ä»…é€‚åˆçº¯å°å†™å­—æ¯çš„ hash
int rkHash(const char* str, const int start, const int len) {
	const int digit = 26;
  int result = 0;
 	for (int i = 0; i < len; ++i) {
    result = result * digit + (str[start + i] - 'a');
  }
  
  return result;
}

int findRK(const char* strMain, const char* strPattern) {
  const int lenMain = std::strlen(strMain);
  const int lenPattern = std::strlen(strPattern);
  
  if (lenMain < lenPattern) return -1;
  
  int hashPattern = rkHash(strPattern, 0, lenPattern);
  for (int i = 0; i < lenMain - lenPattern + 1; ++i) {
    // è¿™é‡Œè¿˜å¯ä»¥ä¼˜åŒ– https://www.jianshu.com/p/7fefc40767ae
    int hashChild = rkHash(strMain, i, lenPattern);
    if (hashChild == hashPattern) {
      // ä¸ºäº†é¿å… hash å†²çªå¸¦æ¥çš„é—®é¢˜ï¼Œå†æ¬¡æ£€æµ‹ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…
      if (isMatch(strMain, i, strPattern, lenPattern))  return i;
    }
  }
  
  return -1;
}
```



### 1.3 BMï¼ˆBoyer-Mooreï¼‰ç®—æ³•

æ–¹æ³•ï¼šå¯»æ‰¾ä¸€ç§è§„å¾‹å¯ä»¥åœ¨æ¨¡å¼ä¸²åŒ¹é…ä¸»ä¸²å¤±è´¥æ—¶**ä¸€æ¬¡å‘åç§»åŠ¨å¤šä½**ï¼Œè€Œä¸æ˜¯ä¸€ä½

```c++

```



### 1.4 KMP ç®—æ³•

> KMPï¼ˆKnuth Morris Prattï¼‰æ˜¯å‘æ˜å®ƒçš„ä¸‰ä¸ªä½œè€…åå­—çš„ç¼©å†™

```c++

```



### 1.5 Trie æ ‘ï¼ˆå­—å…¸æ ‘ï¼‰

```c++

```





## 2. å¤šæ¨¡å¼ä¸²åŒ¹é…

ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆä¸»ä¸²ï¼‰æŸ¥æ‰¾å¤šä¸ªå­—ç¬¦ä¸²ï¼ˆæ¨¡å¼ä¸²ï¼‰

### 2.1 ACï¼ˆAho-Corasickï¼‰è‡ªåŠ¨æœº

```c++

```



# äº”ã€ç®—æ³•æ€æƒ³

<p style="color:red">ä»¥ä¸‹ç®—æ³•å‡ä¸ºæŒ‡å¯¼æ€§ç®—æ³•ï¼Œè®¸å¤šç®—æ³•åŸºäºä»¥ä¸‹ç®—æ³•çš„æ€æƒ³ï¼Œä½†ç”¨çš„ä¸ä»…ä»…åªæœ‰ä»¥ä¸‹ç®—æ³•</p>



## 1. è´ªå¿ƒç®—æ³• Greedy

æ–¹æ³•ï¼šå±€éƒ¨æœ€ä¼˜

1. é—®é¢˜åˆ’åˆ†
2. æ±‚å¾—å±€éƒ¨æœ€ä¼˜
3. ç´¯è®¡å±€éƒ¨æœ€ä¼˜ä»¥æ±‚å¾—æ€»ä½“æœ€ä¼˜



é€‚ç”¨åœºæ™¯ï¼š

- é’ˆå¯¹ä¸€ç»„æ•°æ®ï¼Œæˆ‘ä»¬å®šä¹‰äº†é™åˆ¶å€¼å’ŒæœŸæœ›å€¼ï¼Œå¸Œæœ›ä»ä¸­é€‰å‡ºå‡ ä¸ªæ•°æ®ï¼Œ**åœ¨æ»¡è¶³é™åˆ¶å€¼çš„æƒ…å†µä¸‹ï¼ŒæœŸæœ›å€¼æœ€å¤§**
- **æ¯æ¬¡é€‰æ‹©å½“å‰æƒ…å†µä¸‹**ï¼Œåœ¨å¯¹é™åˆ¶å€¼åŒç­‰è´¡çŒ®é‡çš„æƒ…å†µä¸‹ï¼ˆå‰é¢çš„é€‰æ‹©**ä¸ä¼šå½±å“**åé¢çš„é€‰æ‹©ï¼‰ï¼Œå¯¹æœŸæœ›å€¼**è´¡çŒ®æœ€å¤§çš„æ•°æ®**
- ä¸¾å‡ ä¸ªä¾‹å­çœ‹ä¸‹è´ªå¿ƒç®—æ³•äº§ç”Ÿçš„ç»“æœæ˜¯å¦æ˜¯æœ€ä¼˜çš„
  ä¸¥æ ¼åœ°è¯æ˜è´ªå¿ƒç®—æ³•çš„æ­£ç¡®æ€§ï¼Œéå¸¸å¤æ‚
  å¤§éƒ¨åˆ†èƒ½ç”¨è´ªå¿ƒç®—æ³•è§£å†³çš„é—®é¢˜ï¼Œå…¶çš„æ­£ç¡®æ€§éƒ½æ˜¯æ˜¾è€Œæ˜“è§çš„



**è´ªå¿ƒç®—æ³•è§£å†³é—®é¢˜çš„æ€è·¯ï¼Œå¹¶ä¸æ€»èƒ½ç»™å‡ºæœ€ä¼˜è§£**
ä¾‹ï¼Œæ±‚ä¸‹å›¾æœ€çŸ­è·¯å¾„ï¼ˆå‰é¢çš„é€‰æ‹©å½±å“äº†åé¢çš„é€‰æ‹©ï¼Œä¾¿ä¸é€‚åˆå±€éƒ¨é‡‡ç”¨è´ªå¿ƒç®—æ³•çš„æ–¹å¼ï¼‰

- é‡‡ç”¨è´ªå¿ƒç®—æ³•ï¼šS, A, E, T = 1 + 4 + 4 = 9
- å®é™…æœ€çŸ­è·¯å¾„ï¼šS, B, D, T = 2 + 2 + 2 = 6

![](./images/AlgorithmGreedy.jpg)



### 1.1 åº”ç”¨ï¼šé’±å¸æ‰¾é›¶

é—®é¢˜ï¼š

æœ‰ 1 å…ƒã€2 å…ƒã€5 å…ƒã€10 å…ƒã€20 å…ƒã€50 å…ƒã€100 å…ƒè¿™äº›é¢é¢çš„çº¸å¸ï¼Œå®ƒä»¬çš„å¼ æ•°åˆ†åˆ«æ˜¯ c1ã€c2ã€c5ã€c10ã€c20ã€c50ã€c100ã€‚æˆ‘ä»¬ç°åœ¨è¦ç”¨è¿™äº›é’±æ¥æ”¯ä»˜ K å…ƒï¼Œæœ€å°‘è¦ç”¨å¤šå°‘å¼ çº¸å¸



é—®é¢˜å»ºæ¨¡ï¼š

- æ“ä½œï¼šä» n ä¸ªé¢é¢çš„çº¸å¸ä¸­ï¼ŒæŠ½å–å‡ å¼ çº¸å¸
- é™åˆ¶å€¼ï¼šçº¸å¸çš„é‡‘é¢ä¸€å…± K å…ƒ
- æœŸæœ›å€¼ï¼šçº¸å¸çš„æ•°é‡æœ€å°‘



è´ªå¿ƒè§£æ³•ï¼š

å…ˆç”¨é¢å€¼æœ€å¤§çš„æ¥æ”¯ä»˜ï¼Œå¦‚æœä¸å¤Ÿï¼Œå°±ç»§ç»­ç”¨æ›´å°ä¸€ç‚¹é¢å€¼çš„ï¼Œä»¥æ­¤ç±»æ¨ï¼Œæœ€åå‰©ä¸‹çš„ç”¨ 1 å…ƒæ¥è¡¥é½



### 1.2 åº”ç”¨ï¼šåŒºé—´è¦†ç›–

é—®é¢˜ï¼š
ç±»ä¼¼é—®é¢˜ï¼šä»»åŠ¡è°ƒåº¦ã€æ•™å¸ˆæ’è¯¾

åŒºé—´çš„èµ·å§‹ç«¯ç‚¹å’Œç»“æŸç«¯ç‚¹åˆ†åˆ«æ˜¯ [6,8], [2,4], [3,5], [1,5], [5,9], [8,10]ã€‚ä»ä¸­é€‰å‡ºä¸€éƒ¨åˆ†åŒºé—´ï¼Œè¿™éƒ¨åˆ†åŒºé—´æ»¡è¶³ä¸¤ä¸¤ä¸ç›¸äº¤ï¼ˆç«¯ç‚¹ç›¸äº¤çš„æƒ…å†µä¸ç®—ç›¸äº¤ï¼‰ï¼Œæœ€å¤šèƒ½é€‰å‡ºå¤šå°‘ä¸ªåŒºé—´



é—®é¢˜å»ºæ¨¡ï¼š

- æ“ä½œï¼šä»å·²çŸ¥åŒºé—´é€‰å‡ºä¸€éƒ¨åˆ†åŒºé—´
- é™åˆ¶å€¼ï¼šåŒºé—´å†…éƒ¨æ»¡è¶³ä¸¤ä¸¤ä¸ç›¸äº¤
- æœŸæœ›å€¼ï¼šåŒºé—´çš„æ•°é‡æœ€å¤š



è´ªå¿ƒè§£æ³•ï¼š

ä¼˜å…ˆé€‰æ‹©å·¦è¾¹ç«¯ç‚¹ä¸å‰é¢å·²ç»é€‰æ‹©çš„ä¸é‡åˆçš„ï¼Œå¹¶ä¸”å³ç«¯ç‚¹å°½é‡å°çš„åŒºé—´ï¼Œåˆ™å¯ä»¥å¦‚ä¸‹å›¾å¾—å‡ºæœ€å¤šé€‰æ‹© 3 ä¸ªåŒºé—´
[2,4], [6,8], [8,10]

![](./images/AlgorithmGreedy2.jpg)



### 1.3 åº”ç”¨ï¼šå‹ç¼©å­˜å‚¨ä¸éœå¤«æ›¼ç¼–ç 

é—®é¢˜ï¼š

æœ‰ä¸€ä¸ªåŒ…å« 1000 ä¸ªå­—ç¬¦çš„æ–‡ä»¶ï¼Œæ¯ä¸ªå­—ç¬¦å  1 ä¸ª byteï¼ˆ1byte=8bitsï¼‰ï¼Œå­˜å‚¨è¿™ 1000 ä¸ªå­—ç¬¦å°±ä¸€å…±éœ€è¦ 8000bitsï¼Œé‚£æœ‰æ²¡æœ‰æ›´åŠ èŠ‚çœç©ºé—´çš„å­˜å‚¨æ–¹å¼



é—®é¢˜å»ºæ¨¡ï¼š

- æ“ä½œï¼šå°† 1000 ä¸ªå­—ç¬¦æ–‡ä»¶å­˜å‚¨
- é™åˆ¶ï¼šå­˜å‚¨å¤§å°ä¸èƒ½é«˜äº 1000 byte
- æœŸæœ›ï¼šç”¨æœ€å°çš„å†…å­˜å­˜å‚¨æ•°æ®



è´ªå¿ƒè§£æ³•ï¼šéœå¤«æ›¼ç¼–ç 

ä½¿ç”¨æ­¥éª¤

1. ç»Ÿè®¡å­˜å‚¨å­—ç¬¦æ–‡ä»¶åŒ…å«çš„å­—ç¬¦ç§ç±»
2. æ ¹æ®å­—ç¬¦ç§ç±»å‡ºç°çš„é¢‘ç‡ç»™å­—ç¬¦ç§ç±»è¿›è¡Œéœå¤«æ›¼ç¼–ç ï¼Œé¢‘ç‡è¶Šé«˜ï¼Œç¼–ç é•¿åº¦è¶ŠçŸ­



**éœå¤«æ›¼ç¼–ç ï¼š**

ç‰¹ç‚¹

1. ä¸ç­‰é•¿ç¼–ç 
2. æŸä¸ªç¼–ç ä¸èƒ½æ˜¯å¦ä¸€ä¸ªç¼–ç çš„å‰ç¼€ï¼ˆä¸ºäº†é¿å…è§£å‹ç¼©è¿‡ç¨‹ä¸­çš„æ­§ä¹‰ï¼‰
3. ç‰¹æ®Šçš„äºŒå‰æ ‘å­˜å‚¨æ–¹å¼ï¼ŒèŠ‚ç‚¹æ˜¯éœ€è¦å­˜å‚¨çš„æ•°æ®ï¼Œå·¦èŠ‚ç‚¹ç¼–ç ä¸º 0 ï¼Œå³èŠ‚ç‚¹ç¼–ç ä¸º 1



æ„å»ºæ–¹å¼ï¼š

1. æ¯ä¸ªå­—ç¬¦çœ‹ä½œä¸€ä¸ªèŠ‚ç‚¹ï¼Œç­›é€‰å‡ºå‡ºç°é¢‘ç‡æœ€ä½çš„ä¸¤ä¸ªèŠ‚ç‚¹
2. å°†ç­›é€‰å‡ºçš„ä¸¤ä¸ªèŠ‚ç‚¹é¢‘ç‡å’Œä½œä¸ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹æ˜¯è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
3. å°†æ–°ç”Ÿæˆçš„çˆ¶äº²èŠ‚ç‚¹æ”¾å…¥å‰©ä½™çš„èŠ‚ç‚¹ä¸­ï¼Œé‡å¤ 1ï¼Œ2 æ­¥éª¤ï¼Œç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«ç­›é€‰å‡ºæ¥
4. å·¦èŠ‚ç‚¹ç¼–ç ä¸º 0 ï¼Œå³èŠ‚ç‚¹ç¼–ç ä¸º 1ï¼Œä»æ„å»ºçš„éœå¤«æ›¼æ ‘æ ¹èŠ‚ç‚¹å¼€å§‹æŸ¥æ‰¾èŠ‚ç‚¹ç´¢ç»è¿‡çš„ç¼–ç ä¸ºéœå¤«æ›¼ç¼–ç 

![](./images/Huffman.png)



## 2. åˆ†æ²»ç®—æ³• Divide and Conquer

> åˆ†æ²»ç®—æ³•æ˜¯ä¸€ç§å¤„ç†é—®é¢˜çš„æ€æƒ³ï¼Œé€’å½’æ˜¯ä¸€ç§ç¼–ç¨‹æŠ€å·§



æ–¹æ³•ï¼šåˆ†è€Œæ²»ä¹‹ 

1. å°†åŸé—®é¢˜åˆ’åˆ†æˆå‡ ä¸ªè§„æ¨¡è¾ƒå°ï¼Œå¹¶ä¸”<u>ç»“æ„ä¸åŸé—®é¢˜ç›¸ä¼¼</u>çš„å­é—®é¢˜
2. é€’å½’åœ°è§£å†³è¿™äº›å­é—®é¢˜
3. åˆå¹¶æ‰€æœ‰å­é—®é¢˜çš„ç»“æœï¼Œå°±å¾—åˆ°åŸé—®é¢˜çš„è§£



é€‚ç”¨åœºæ™¯ï¼ˆå’Œé€’å½’ç±»ä¼¼ï¼‰

1. åŸé—®é¢˜ä¸åˆ†è§£æˆçš„å°é—®é¢˜å…·æœ‰ç›¸åŒçš„æ¨¡å¼
2. åŸé—®é¢˜åˆ†è§£æˆçš„å­é—®é¢˜å¯ä»¥ç‹¬ç«‹æ±‚è§£ï¼Œå­é—®é¢˜ä¹‹é—´æ²¡æœ‰ç›¸å…³æ€§ï¼Œ
3. å…·æœ‰åˆ†è§£ç»ˆæ­¢æ¡ä»¶ï¼Œå½“é—®é¢˜è¶³å¤Ÿå°æ—¶ï¼Œå¯ä»¥ç›´æ¥æ±‚è§£
4. å¯ä»¥å°†å­é—®é¢˜åˆå¹¶æˆåŸé—®é¢˜
   è¿™ä¸ªåˆå¹¶æ“ä½œçš„å¤æ‚åº¦ä¸èƒ½å¤ªé«˜ï¼Œå¦åˆ™å°±èµ·ä¸åˆ°å‡å°ç®—æ³•æ€»ä½“å¤æ‚åº¦çš„æ•ˆæœ



åº”ç”¨ï¼šGoogle çš„ MapRedue ç¼–ç¨‹æ¨¡å‹



### 2.1 åº”ç”¨ï¼šæ±‚ä¸€ç»„æ•°æ®çš„é€†åºå¯¹ä¸ªæ•°

é€šè¿‡ä¿®æ”¹å½’å¹¶æ’åºæ¥è§£å†³é—®é¢˜

```c++
int num = 0; // å…¨å±€å˜é‡æˆ–è€…æˆå‘˜å˜é‡

// é€†åºå¯¹ä¸ªæ•°
int count(int* arr, int arrLength) {
  num = 0;
  mergeSortCounting(arr, 0, arrLength-1);
  return num;
}

void mergeSortCounting(int* arr, int start, int end) {
  if (start >= end) return;
  int middle = (start + end) / 2;
  
  // 1. åˆ’åˆ†é—®é¢˜
  mergeSortCounting(arr, middle,  	 start);
  mergeSortCounting(arr, middle + 1, end);
  
  // 2. è§£å†³ï¼Œåˆå¹¶é—®é¢˜
  merge(arr, start, middle, end);
}

void merge(int* arr, int start, int middle, int end) {
  const int size = end - start + 1;
  int tmp[size];
	int i = start;
  int j = middle + 1;
  int k = 0;
  // æ¯”è¾ƒå‰åä¸¤éƒ¨åˆ†å…ƒç´ ï¼Œä»å°åˆ°å¤§æ’åˆ—åœ¨ tmp æ•°ç»„é‡Œ
  while (i <= middle && j <= end) {
    if (arr[i] <= arr[j]) {
      tmp[++k] = arr[++i];
    } else {
      // è®°å½•åŸæ•°ç»„ä¸­ start åˆ° middle ä¹‹å‰æ¯” a[j] å¤§çš„å…ƒç´ ä¸ªæ•°ï¼ˆé€†åºå¯¹æ•°ï¼‰
      // å› ä¸ºæ˜¯åŸæ•°ç»„ï¼Œæ‰€ä»¥ï¼Œè¿™è¦ middle - iï¼Œå› ä¸ºæ˜¯ç”±ç´¢å¼•è®¡ç®—å¾—åˆ°çš„ä¸ªæ•°ï¼Œæ‰€ä»¥ +1
      num += (middle - i + 1);
      tmp[++k] = arr[++j];
    }
  }
  // å¦‚æœå‰åŠéƒ¨åˆ†å‰©ä¸‹ï¼Œcopy åˆ°ç¼“å­˜æ•°ç»„
  while (i <= middle) {
    tmp[++k] = arr[++i];
  }
  // å¦‚æœååŠéƒ¨åˆ†å‰©ä¸‹ï¼Œcopy åˆ°ç¼“å­˜æ•°ç»„
  while (j <= end) {
    tmp[++k] = arr[++j];
  }
  // æ’å¥½åºçš„ tmp æ•°ç»„ copy å›åŸæ•°ç»„
  memcpy(&(arr[start]), &(tmp[0]), size * sizeof(int));
}
```



### 2.2  åº”ç”¨ï¼šæ±‚å‡ºäºŒç»´å¹³é¢ä¸­ç›¸è·æœ€è¿‘çš„ä¸¤ä¸ªç‚¹

åˆ©ç”¨å½’å¹¶æ’åºçš„æµç¨‹

1. é’ˆå¯¹å¹³é¢ä¸Šçš„æ‰€æœ‰ç‚¹æŠŠå¹³é¢ä¸æ–­åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†
2. ç›´åˆ°ä¸€ä¸ªå¹³é¢å†…åªæœ‰ä¸¤ä¸ªç‚¹
3. æ ¹æ®æ¯ä¸ªå¹³é¢å†…ä¸¤ä¸ªç‚¹çš„è·ç¦»ï¼Œå°†ç‚¹æˆå¯¹æ’åº



### 2.3  åº”ç”¨ï¼šè®¡ç®—å¤šç»´åº¦çŸ©é˜µä¹˜ç§¯

åˆ©ç”¨å½’å¹¶æ’åºçš„æµç¨‹ï¼Œè¯¦ç»†çš„è®¡ç®—è§[æ–¯ç‰¹æ‹‰æ£®çŸ©é˜µè¿ç®—](https://www.csdn.net/gather_29/MtTaIgxsNDI5ODYtYmxvZwO0O0OO0O0O.html)

1. å°†å¤šç»´åº¦çš„çŸ©é˜µä¹˜ç§¯ä¸æ–­åˆ’åˆ†ä¸º 2 X 2 çš„å››éƒ¨åˆ†
2. ç›´åˆ°æ¯éƒ¨åˆ†çŸ©é˜µåªåŒ…å« 1 ä¸ªå…ƒç´ ä¸ºæ­¢
3. æ ¹æ®æ¯ä¸ªå­çŸ©é˜µçš„ä¹˜ç§¯è®¡ç®—å€¼
4. å°†å­çŸ©é˜µçš„ç»“æœåˆå¹¶





## 3. å›æº¯ç®—æ³• Backtracking

æ–¹æ³•ï¼šå¤±è´¥åå›æº¯

1. æšä¸¾ï¼šç©·ä¸¾æ‰€æœ‰çš„è§£ï¼Œæ‰¾åˆ°æ»¡è¶³æœŸæœ›çš„è§£
2. åˆ’åˆ†ï¼šæŠŠé—®é¢˜æ±‚è§£çš„è¿‡ç¨‹åˆ†ä¸ºå¤šä¸ªé˜¶æ®µ
   ä¸ºäº†æœ‰è§„å¾‹åœ°æšä¸¾æ‰€æœ‰å¯èƒ½çš„è§£ï¼Œé¿å…é—æ¼å’Œé‡å¤
3. é€‰æ‹©ï¼šæ¯ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬éƒ½ä¼šé¢å¯¹ä¸€ä¸ªå²”è·¯å£ï¼Œæˆ‘ä»¬å…ˆéšæ„é€‰ä¸€æ¡è·¯èµ°
4. å›æº¯ï¼šå½“å‘ç°è¿™æ¡è·¯èµ°ä¸é€šçš„æ—¶å€™ï¼ˆä¸ç¬¦åˆæœŸæœ›çš„è§£ï¼‰ï¼Œå°±å›é€€åˆ°ä¸Šä¸€ä¸ªå²”è·¯å£ï¼Œå¦é€‰ä¸€ç§èµ°æ³•ç»§ç»­èµ°



é€‚åˆåœºæ™¯ï¼šç¼ºä¹è§„å¾‹æˆ–ç›®å‰ä¸äº†è§£å…¶è§„å¾‹çš„æœç´¢åœºæ™¯



### 3.1 åº”ç”¨ï¼šå…«çš‡åé—®é¢˜

é—®é¢˜ï¼š

- æœ‰ä¸€ä¸ª 8 X 8 çš„æ£‹ç›˜ï¼Œå¸Œæœ›å¾€é‡Œæ”¾ 8 ä¸ªæ£‹å­ï¼ˆçš‡åï¼‰
- æ¯ä¸ªæ£‹å­æ‰€åœ¨çš„è¡Œã€åˆ—ã€å¯¹è§’çº¿éƒ½ä¸èƒ½æœ‰å¦ä¸€ä¸ªæ£‹å­

```c++
int gEightQueenCols[8];

void eight_queens_print() {
    using namespace std;
    for (int row = 0; row < 8; ++row) {
        int col;
        for (col = 0; col < gEightQueenCols[row]; ++col)
            cout << "* ";
        cout <<"Q ";
        for (col = gEightQueenCols[row] + 1; col < 8; ++col)
            cout << "* ";
        cout << endl;
    }
    cout << "\n";
}

//   0 1 2
// 0 0 # 2
// 1 # 0 #
// 2 2 # 0
bool check_pos_valid(int rowOrigin, int colOrigin) {
    for (int row = 0, col = 0; row < rowOrigin; ++row) {
        col = gEightQueenCols[row];
        if (colOrigin == col)                       // åŒåˆ—
            return false;
        if ((row + col) == (rowOrigin + colOrigin)) // åŒå³ä¸Šå¯¹è§’çº¿
            return false;
        if ((row - col) == (rowOrigin - colOrigin)) // åŒå·¦ä¸Šå¯¹è§’çº¿
            return false;
    }

    return true;
}

void eight_queens(int row) {
    if (row > 7) {
        eight_queens_print();     // å‘ç°ä¸€ç§åï¼Œä¹Ÿä¼šå›æº¯åˆ°ä¸Šä¸€çŠ¶æ€ï¼Œç»§ç»­æŸ¥æ‰¾ä¸‹ä¸€ç§æ–°çš„æ‘†æ³•
        gEightQueenCols[row] = 0; // é‡ç½®ä¸ºé»˜è®¤æ•°æ®
        return;
    }

    for (int col = 0; col < 8; ++col) {
        if (check_pos_valid(row, col)) {
            gEightQueenCols[row] = col;
            eight_queens(row + 1);
          	// é‡ç½®ä¸ºé»˜è®¤æ•°æ®ï¼Œé˜²æ­¢å›æº¯æ—¶ä¸Šä¸€æ¬¡çš„æ•°æ®è®© check_pos_valid åˆ¤æ–­å¤±è¯¯
            gEightQueenCols[row] = 0;
        }
    }
    // å½“å‰è¡Œæ²¡æœ‰é€‚åˆçš„åˆ—ï¼Œé€šè¿‡é€’å½’è°ƒç”¨è¿”å›ï¼Œå›æº¯åˆ°ä¸Šä¸€è¡Œçš„é€‰æ‹©ï¼Œé€‰æ‹©å…¶ä»–å¯èƒ½æƒ…å†µ
}

void TestCode() {
  eight_queens(0);
}
```



### 3.2 åº”ç”¨ï¼š0-1 èƒŒåŒ…

é—®é¢˜ï¼š

æœ‰ä¸€ä¸ªèƒŒåŒ…ï¼ŒèƒŒåŒ…æ€»çš„æ‰¿è½½é‡é‡æ˜¯ w kgã€‚ç°åœ¨æˆ‘ä»¬æœ‰ n ä¸ªç‰©å“ï¼Œæ¯ä¸ªç‰©å“çš„é‡é‡ä¸ç­‰ï¼Œå¹¶ä¸”ä¸å¯åˆ†å‰²ã€‚æˆ‘ä»¬ç°åœ¨æœŸæœ›é€‰æ‹©å‡ ä»¶ç‰©å“ï¼Œè£…è½½åˆ°èƒŒåŒ…ä¸­ã€‚åœ¨ä¸è¶…è¿‡èƒŒåŒ…æ‰€èƒ½è£…è½½é‡é‡çš„å‰æä¸‹ï¼Œå¦‚ä½•è®©èƒŒåŒ…ä¸­ç‰©å“çš„æ€»é‡é‡æœ€å¤§ï¼Ÿ

```c++
int weightMax = 0;
void package(int* itemsW, int itemsIdx, int itemsWCount, int weight, int capacity) {
  if (weight == capacity || itemsIdx == itemsWCount) {
    if (weight > weightMax) weightMax = weight; // æ»¡è¶³æ¡ä»¶åä¹Ÿä¼šå›æº¯ï¼Œä½†ä¼šè®°å½•ä¸‹å½“å‰çš„æœ€å¤§å€¼
    return;
  }
  // éå†åˆ°æœ€æ·±å¤„ï¼Œå¦‚æœä¸ç¬¦åˆæƒ…å†µä¼šå‘åå›æº¯
  package(itemsW, itemsIdx + 1, itemsWCount, weight, capacity);
  
  // æ ¹æ®æ¡ä»¶åˆ¤æ–­å½“å‰æ–¹æ³•æ˜¯å¦å¯è¡Œï¼Œä¸è¡Œå°±é€šè¿‡é€’å½’çš„å›è°ƒå›æº¯åˆ°ä¸Šä¸€çŠ¶æ€
  if (weight + itemsW[itemsIdx] <= capacity) {
    package(itemsW, itemsIdx + 1, itemsWCount, weight + itemsW[itemsIdx], capacity);
  }
}

void TestCode() {
  int items[7] = { 30, 2, 3, 4, 40, 20, 9 };
  package(items, 0, 7, 0, 100);
  std::cout << "èƒŒåŒ…æœ€å¤§æ‰¿é‡" << weightMax << " kg" << std::endl;
}
```



### 3.2 åº”ç”¨ï¼šæ­£åˆ™è¡¨è¾¾å¼

é—®é¢˜ï¼š

å‡è®¾æ­£åˆ™è¡¨è¾¾å¼ä¸­åªåŒ…å« `*` å’Œ `?` è¿™ä¸¤ç§é€šé…ç¬¦ï¼Œå¯¹äºç»™å®šçš„æ–‡æœ¬ï¼Œèƒ½å¦è·Ÿç»™å®šçš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ï¼Œå…¶ä¸­ï¼š

- `*` åŒ¹é…ä»»æ„å¤šä¸ªï¼ˆå¤§äºç­‰äº 0 ä¸ªï¼‰ä»»æ„å­—ç¬¦
- `?` åŒ¹é…é›¶ä¸ªæˆ–è€…ä¸€ä¸ªä»»æ„å­—ç¬¦

```c++
class Pattern {
private:
  bool matched = false;
  char* pattern; // æ­£åˆ™è¡¨è¾¾å¼
  int pLen;      // æ­£åˆ™è¡¨è¾¾å¼é•¿åº¦

public:
   Pattern(char* pattern, int pLen) {
    this->pattern = pattern;
    this->pLen = pLen;
  }

  bool match(char* text, int tLen) { // æ–‡æœ¬ä¸²åŠé•¿åº¦
    matched = false;
    rmatch(0, 0, text, tLen);
    return matched;
  }

  void rmatch(int tIdx, int pIdx, char* text, int tLen) {
    if (matched) return;

    if (pIdx == pLen) {                   // æ­£åˆ™è¡¨è¾¾å¼åˆ°ç»“å°¾äº†
      if (tIdx == tLen) matched = true;   // æ–‡æœ¬ä¸²ä¹Ÿåˆ°ç»“å°¾äº†
      return;
    }
    if (pattern[pIdx] == '*') {           // * åŒ¹é…ä»»æ„ä¸ªå­—ç¬¦
      for (int k = 0; k <= tLen-tIdx; ++k) {
        rmatch(tIdx+k, pIdx+1, text, tLen);
      }
    } else if (pattern[pIdx] == '?') {    // ? åŒ¹é… 0 ä¸ªæˆ–è€… 1 ä¸ªå­—ç¬¦
      rmatch(tIdx,   pIdx+1, text, tLen);
      rmatch(tIdx+1, pIdx+1, text, tLen);
    } else if (tIdx < tLen && pattern[pIdx] == text[tIdx]) { // çº¯å­—ç¬¦åŒ¹é…æ‰è¡Œ
      rmatch(tIdx+1, pIdx+1, text, tLen);
    }
  }
};
```





## 4. åŠ¨æ€è§„åˆ’ Dynamic Programming








# å¼•ç”¨

- [åå¤§ç»å…¸æ’åºç®—æ³•æ€»ç»“](https://www.cnblogs.com/guoyaohua/p/8600214.html)
- [è°ˆè°ˆ STL ä¸­çš„ std::sort](https://liam.page/2018/09/18/std-sort-in-STL/)
- [è°ˆè°ˆå†…çœå¼æ’åºç®—æ³•](https://liam.page/2018/08/29/introspective-sort/)
- [è°ˆè°ˆåŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•çš„å¤æ‚åº¦ä¸‹ç•Œ](https://liam.page/2018/08/28/lower-bound-of-comparation-based-sort-algorithm/)
- [Boyer-Moore](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf)

